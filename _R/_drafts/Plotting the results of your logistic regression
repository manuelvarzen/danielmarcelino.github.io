# Plotting the results of your logistic regression Part 1: Continuous by categorical interaction

We’ll run a nice, complicated logistic regresison and then make a plot that highlights a continuous by categorical interaction.

set.seed(24601) # setting this so the random results will be repeatable 

library(MASS)
covmat <- matrix(c(1.0,   0.2,   0.6, 
                   0.2,   1.0,  -0.5, 
                   0.6,  -0.5,   1.0), nrow=3) # the true cov matrix for my data
data <- mvrnorm(300, mu=c(0,0,0), Sigma=covmat) # generate random data that match that cov matrix
colnames(data) <- c("X1", "X2", "DV")
data <- as.data.frame(data)
data$group <- gl(n=3, k=ceiling(nrow(data)/3), labels=c("a", "b", "c", "d"))
# add some group differences and interaction stuff...
data$DV <- with(data, ifelse(group=="c" & X1 > 0, DV+rnorm(n=1, mean=1), 
                             ifelse(group=="b" & X1 > 0, DV+rnorm(n=1, mean=2) , DV)))
# make DV binary
data$DV <- ifelse(data$DV > 0, 1, 0)
head(data)



Get the coefficients from your logistic regression model

First, whenever you’re using a categorical predictor in a model in R (or anywhere else, for that matter), make sure you know how it’s being coded!! For this example, we want it dummy coded (so we can easily plug in 0’s and 1’s to get equations for the different groups). This is called contr.treatment() in R.

contrasts(data$group)

# Great, that's what we wanted. And we can see that a is the reference group.
# If you want to change what contrasts will run, you can add an argument to the glm() call. For example contrasts="contr.treatment" will make it traditional dummy coding if it isn't already.

Now we can run that model.

# note this use of exponent in a formula will give us all 2-way interactions
model <- glm(DV ~ (X1 + X2 + group)^2, 
             data=data, na.action="na.exclude",  family="binomial") 
             
summary(model)

model$coef


# save the coefficient values so we can use them in the equations
b0 <- model$coef[1] # intercept
X1 <- model$coef[2]
X2 <- -model$coef[3]
groupb <- model$coef[4]
groupc <- model$coef[5]
X1.X2 <- model$coef[6]
X1.groupb <- model$coef[7]
X1.groupc <- model$coef[8]
X2.groupb <- model$coef[9]
X2.groupc <- model$coef[10]

Note: If you were working in SPSS (or for some other reason you have run a model but can’t generate a plot for it), you can enter in your coefficients here, like this:

b0 <- -0.5872841 # intercept
X1 <- 2.6508212
X2 <- -2.2599250
groupb <- 2.2110951
groupc <- 0.6649971
X1.X2 <- 0.1201166
X1.groupb <- 2.7323113
X1.groupc <- -0.6816327
X2.groupb <- 0.8476695
X2.groupc <- 0.4682893

Calculate probabilities for the plot

First, decide what variable you want on your x-axis. That’s the only variable we’ll enter as a whole range. (The range we set here will determine the range on the x-axis of the final plot, by the way.)

X1_range <- seq(from=min(data$X1), to=max(data$X1), by=.01)

Next, compute the equations for each group in logit terms. These equations need to include every coefficient for the model you ran. You’ll need to plug in values for all but one variable – whichever variable you decided will be displayed on the x-axis of your plot. You make a separate equation for each group by plugging in different values for the group dummy codes.

X2_val <- mean(data$X2) # by plugging in the mean as the value for X2, I'll be generating plots that show the relationship between X1 and the outcome "for someone with an average X2".

a_logits <- b0 + 
  X1*X1_range + 
  X2*X2_val + 
  groupb*0 + 
  groupc*0 + 
  X1.X2*X1_range*X2_val + 
  X1.groupb*X1_range*0 + 
  X1.groupc*X1_range*0 + 
  X2.groupb*X2_val*0 + 
  X2.groupc*X2_val*0 # the reference group

b_logits <- b0 + 
  X1*X1_range + 
  X2*X2_val + 
  groupb*1 + 
  groupc*0 + 
  X1.X2*X1_range*X2_val + 
  X1.groupb*X1_range*1 + 
  X1.groupc*X1_range*0 + 
  X2.groupb*X2_val*1 + 
  X2.groupc*X2_val*0

c_logits <- b0 + 
  X1*X1_range + 
  X2*X2_val + 
  groupb*0 + 
  groupc*1 + 
  X1.X2*X1_range*X2_val + 
  X1.groupb*X1_range*0 + 
  X1.groupc*X1_range*1 + 
  X2.groupb*X2_val*0 + 
  X2.groupc*X2_val*1

# Compute the probibilities (this is what will actually get plotted):
a_probs <- exp(a_logits)/(1 + exp(a_logits))
b_probs <- exp(b_logits)/(1 + exp(b_logits))
c_probs <- exp(c_logits)/(1 + exp(c_logits))

Plot time!

# We'll start by plotting the ref group:
plot(X1_range, a_probs, 
     ylim=c(0,1),
     type="l", 
     lwd=3, 
     lty=2, 
     col="gold", 
     xlab="X1", ylab="P(outcome)", main="Probability of super important outcome")


# Add the line for people who are in the b group
lines(X1_range, b_probs, 
      type="l", 
      lwd=3, 
      lty=3, 
      col="turquoise2")

# Add the line for people who are in the c group
lines(X1_range, c_probs, 
      type="l", 
      lwd=3, 
      lty=4, 
      col="orangered")

# add a horizontal line at p=.5
abline(h=.5, lty=2)

Or, you can do it in ggplot2!

library(ggplot2); library(tidyr)
# first you have to get the information into a long dataframe, which is what ggplot likes :)
plot.data <- data.frame(a=a_probs, b=b_probs, c=c_probs, X1=X1_range)
plot.data <- gather(plot.data, key=group, value=prob, a:c)
head(plot.data)


ggplot(plot.data, aes(x=X1, y=prob, color=group)) + # asking it to set the color by the variable "group" is what makes it draw three different lines
  geom_line(lwd=2) + 
  labs(x="X1", y="P(outcome)", title="Probability of super important outcome") 
  

# Plotting the results of your logistic regression Part 2: Continuous by continuous interaction

Last time, we ran a nice, complicated logistic regression and made a plot of the a continuous by categorical interaction. This time, we’ll use the same model, but plot the interaction between the two continuous predictors instead, which is a little weirder (hence part 2).



Calculate probabilities for the plot

Again, we’ll put X1 on the x-axis. That’s the only variable we’ll enter as a whole range.

X1_range <- seq(from=min(data$X1), to=max(data$X1), by=.01)

Next, compute the equations for each line in logit terms.
Pick some representative values for the other continuous variable

Just like last time, we’ll need to plug in values for all but one variable (X1, which is going on the x-axis of the plot), but this time we’ll pick some representative values for the other continuous predictor, X2, and plug those in to get a separate line for each representative value of X2. Typical choices are high (1SD above the mean), medium (the mean), and low (1SD below the mean) X2. Another great choice is max, median, and min. You can also do 4 or 5 lines instead of just 3, if you want. It’s your party.

Whatever you decide, I recommend checking to make sure the “representative” values you’re plugging in actually make sense given your data. For example, you may not actually have any cases with X2 value 1SD above the mean, in which case maybe you just want to put in max(X2) for the high case instead. It’s kinda weird to plot your models at values that don’t actually exist in your data (cue Twilight Zone music).

summary(data$X2)

(X2_l <- mean(data$X2) - sd(data$X2) )

(X2_m <- mean(data$X2) )

(X2_h <- mean(data$X2) + sd(data$X2) )




Now we can go ahead and plug those values into the rest of the equation to get the expected logits across the range of X1 for each of our “groups” (hypothetical low X2 people, hypothetical average X2 people, hypothetical high X2 people).
If you ran your model in SPSS and you just have the coefficients…

You’ll need to actually calculate the predicted probabilities yourself. Write out the equation for your model and plug in values for everything except the variable that will go on the x-axis.

Remember, these equations need to include every coefficient for the model you ran, whether or not you actually care about plotting them.

In this case, lots of it will just drop out because I’ll be plugging in 0’s for all of the dummy codes (we’re only looking at group a), but I encourage you to keep the terms in your code, so you don’t forget that all of those predictors are still in your model, you’re just holding them constant while you plot. We’re not interested in plotting the categorical predictor right now, but it’s still there in the model, so we need to just pick a group from it and enter the dummy codes for it. The plot will show us the interaction between X1 and X2 for the reference group (for 3-way interactions, you’ll have to wait for part 3!).

X2_l_logits <- b0 + 
  X1*X1_range + 
  X2*X2_l + 
  groupb*0 + 
  groupc*0 + 
  X1.X2*X1_range*X2_l + 
  X1.groupb*X1_range*0 + 
  X1.groupc*X1_range*0 + 
  X2.groupb*X2_l*0 + 
  X2.groupc*X2_l*0 

X2_m_logits <- b0 + 
  X1*X1_range + 
  X2*X2_m + 
  groupb*0 + 
  groupc*0 + 
  X1.X2*X1_range*X2_m + 
  X1.groupb*X1_range*0 + 
  X1.groupc*X1_range*0 + 
  X2.groupb*X2_m*0 + 
  X2.groupc*X2_m*0 

X2_h_logits <- b0 + 
  X1*X1_range + 
  X2*X2_h + 
  groupb*0 + 
  groupc*0 + 
  X1.X2*X1_range*X2_h + 
  X1.groupb*X1_range*0 + 
  X1.groupc*X1_range*0 + 
  X2.groupb*X2_h*0 + 
  X2.groupc*X2_h*0 

# Compute the probibilities (this is what will actually get plotted):
X2_l_probs <- exp(X2_l_logits)/(1 + exp(X2_l_logits))
X2_m_probs <- exp(X2_m_logits)/(1 + exp(X2_m_logits))
X2_h_probs <- exp(X2_h_logits)/(1 + exp(X2_h_logits))

If you ran your model in R, then you can just use predict()

Easy peasy! And, most importantly, less typing — which means fewer errors. Thanks to John for reminding me of this handy function! You make a new data frame with the predictor values you want to use (i.e. the whole range for X1, group a, and the representative values we picked for X2), and then when you run predict() on it, for each row in the data frame it will generate the predicted value for your DV from the model you saved. The expand.grid() function is a quick and easy way to make a data frame out of all possible combinations of the variables provided. Perfect for this situation!

#make a new data frame with the X values you want to predict 
generated_data <- as.data.frame(expand.grid(X1=X1_range, X2=c(X2_l, X2_m, X2_h), group="a") )
head(generated_data)

summary(generated_data)

#use `predict` to get the probability using type='response' rather than 'link' 
generated_data$prob <- predict(model, newdata=generated_data, type = 'response')
head(generated_data) 


# let's make a factor version of X2, so we can do gorgeous plotting stuff with it later :)
generated_data$X2_level <- factor(generated_data$X2, labels=c("low (-1SD)", "mean", "high (+1SD)"), ordered=T)
head(generated_data) 



Plot time!

In base R…

# We'll start by plotting the low X2 group:
plot(X1_range, X2_l_probs, 
     ylim=c(0,1),
     type="l", 
     lwd=3, 
     lty=2, 
     col="red", 
     xlab="X1", ylab="P(outcome)", main="Probability of super important outcome")


# Add the line for mean X2
lines(X1_range, X2_m_probs, 
      type="l", 
      lwd=3, 
      lty=3, 
      col="green")

# Add the line for high X2
lines(X1_range, X2_h_probs, 
      type="l", 
      lwd=3, 
      lty=4, 
      col="blue")

# add a horizontal line at p=.5
abline(h=.5, lty=2)




Or, you can do it in ggplot2!

library(ggplot2); library(tidyr)
# first you have to get the information into a long dataframe, which is what ggplot likes :)

# if you calculated the predicted probabilities by writing out the equations, you can combine that all into a dataframe now, and use gather() to make it long
plot.data <- data.frame(low=X2_l_probs, mean=X2_m_probs, high=X2_h_probs, X1=X1_range)
plot.data <- gather(plot.data, key=X2_level, value=prob, -X1) # this means gather all of the columns except X1

# if you used predict(), then everything is already in a nice dataframe for you
plot.data <- generated_data

# check out your plotting data
head(plot.data)

##          X1        X2 group        prob   X2_level
## 1 -2.770265 -1.062196     a 0.005614200 low (-1SD)
## 2 -2.760265 -1.062196     a 0.005756836 low (-1SD)
## 3 -2.750265 -1.062196     a 0.005903074 low (-1SD)
## 4 -2.740265 -1.062196     a 0.006053005 low (-1SD)
## 5 -2.730265 -1.062196     a 0.006206719 low (-1SD)
## 6 -2.720265 -1.062196     a 0.006364312 low (-1SD)

ggplot(plot.data, aes(x=X1, y=prob, color=X2_level)) + 
  geom_line(lwd=2) + 
  labs(x="X1", y="P(outcome)", title="Probability of super important outcome") 
  
  

# Plotting the results of your logistic regression Part 3: 3-way interactions

If you can interpret a 3-way interaction without plotting it, go find a mirror and give yourself a big sexy wink.

hat’s impressive.

For the rest of us, looking at plots will make understanding the model and results so much easier. And even if you are one of those lucky analysts with the working memory capacity of a super computer, you may want this code so you can use plots to help communicate a 3-way interaction to your readers.

Let’s add a 3-way interaction. Instead of re-running the whole model, we can use the nifty update() function. This will make the change to the model (adding the 3-way interaction), and automatically refit the whole thing. (It is also fine to just re-run the model — you’ll get the exact same results. I just wanted to show off the update() function.)

new.model <- update(model, ~ . + X1:X2:group) # the . stands in for the whole formula we had before

# if you wanted to specify the whole model from scratch instead of using update():
new.model <- glm(DV ~ X1*X2*group, 
             data=data, na.action="na.exclude",  family="binomial")  

summary(new.model)


Calculate probabilities for the plot

Again, we’ll put X1 on the x-axis. That’s the only variable we’ll enter as a whole range.

X1_range <- seq(from=min(data$X1), to=max(data$X1), by=.01)


Next, compute the equations for each line in logit terms.
Pick some representative values for the other continuous variable

Just like last time, we’ll plug in some representative values for X2, so we can have separate lines for each representative level of X2.

X2_l <- mean(data$X2) - sd(data$X2) 
X2_m <- mean(data$X2)
X2_h <- mean(data$X2) + sd(data$X2)
# check that your representative values actually fall within the observed range for that variable
summary(data$X2)

c(X2_l, X2_m, X2_h)


Now we can go ahead and plug those values into the rest of the equation to get the expected logits across the range of X1 for each of our “groups” (hypothetical low X2 people, hypothetical average X2 people, hypothetical high X2 people). We’ll also plug in the dummy codes for each of the three groups (a, b, and c). And we’ll calculate the predicted probabilities of the DV for each combination of X2 level and group.

But instead of literally writing out all of the equations (9 of them!!), we’ll just use the fun-and-easy predict() function.

If you ran your model in SPSS, so you only have the coefficients and not the whole model as an R object, you can still make the plots — you just need to spend some quality time writing out those equations. For examples of how to do this (for just 3 equations, but you get the idea) see Part 1 and Part 2 in this series.

To use predict(), you make a new data frame with the predictor values you want to use (i.e. the whole range for X1, group a, and the representative values we picked for X2), and then when you run predict() on it, for each row in the data frame it will generate the predicted value for your DV from the model you saved. The expand.grid() function is a quick and easy way to make a data frame out of all possible combinations of the variables provided. Perfect for this situation!

#make a new data frame with the X values you want to predict 
generated_data <- as.data.frame(expand.grid(X1=X1_range, X2=c(X2_l, X2_m, X2_h), group=c("a", "b", "c") ))
head(generated_data)


#use `predict` to get the probability using type='response' rather than 'link' 
generated_data$prob <- predict(new.model, newdata=generated_data, type = 'response')
head(generated_data) 


# let's make a factor version of X2, so we can do gorgeous plotting stuff with it later :)
generated_data$X2_level <- factor(generated_data$X2, labels=c("low (-1SD)", "mean", "high (+1SD)"), ordered=T)
summary(generated_data)


Plot time!

This kind of situation is exactly when ggplot2 really shines. We want multiple plots, with multiple lines on each plot. Of course, this is totally possible in base R (see Part 1 and Part 2 for examples), but it is so much easier in ggplot2. To do this in base R, you would need to generate a plot with one line (e.g. group a, low X2), then add the additional lines one at a time (group a, mean X2; group a, high X2), then generate a new plot (group b, low X2), then add two more lines, then generate a new plot, then add two more lines. Sigh.

Not to go down too much of a rabbit hole, but this illustrates what is (in my opinion) the main difference between base R graphics and ggplot2: base graphics are built for drawing, whereas ggplot is built for visualizing data. It’s the difference between specifying each line and drawing them on your plot vs. giving a whole data frame to the plotting function and telling it which variables to use and how. Depending on your needs and preferences, base graphics or ggplot may be a better choice for you. For plotting complex model output, like a 3-way interaction, I think you’ll generally find that ggplot2 saves the day.

library(ggplot2)

plot.data <- generated_data

# check out your plotting data
head(plot.data)


ggplot(plot.data, aes(x=X1, y=prob, color=X2_level)) + 
  geom_line(lwd=2) + 
  labs(x="X1", y="P(outcome)", title="Probability of super important outcome") +
  facet_wrap(~group) # i love facet_wrap()! it's so great. you should fall in love, too, and use it all the time.
  
  
  # let's try flipping it, so the facets are by X2 level and the lines are by group
  ggplot(plot.data, aes(x=X1, y=prob, color=group)) + 
    geom_line(lwd=2) + 
    labs(x="X1", y="P(outcome)", title="Probability of super important outcome") +
    facet_wrap(~X2_level)
	
	
	# want it all on one plot? you can set the color to the interaction of group and X2_level:
	ggplot(plot.data, aes(x=X1, y=prob, color=group:X2_level)) + 
	  geom_line(lwd=2) + 
	  labs(x="X1", y="P(outcome)", title="Probability of super important outcome")

	
	
	
	For something like this, you may want to manually specify the colors, to make the plot easier to read. For more details about manually setting colors in ggplot2, see this R Club post.

	library(RColorBrewer)
	# pick some nice colors. I want all shades of red for a, green for b, and blue for c.
	a_colors <- brewer.pal(9,"Reds")[c(4,6,9)] # I'm getting all 9 shades and just picking the 3 I want to use 
	b_colors <- brewer.pal(9,"Greens")[c(4,6,9)]
	c_colors <- brewer.pal(9,"Blues")[c(4,6,9)] 
	colors <- c(a_colors, b_colors, c_colors)
	colors # this is how R saves color values

	## [1] "#FC9272" "#EF3B2C" "#67000D" "#A1D99B" "#41AB5D" "#00441B" "#9ECAE1"
	## [8] "#4292C6" "#08306B"

	ggplot(plot.data, aes(x=X1, y=prob, color=group:X2_level)) + 
	  geom_line(lwd=2) + 
	  labs(x="X1", y="P(outcome)", title="Probability of super important outcome") +
	  scale_color_manual(values=colors)
	  
	  
	  # you can also change the line type based on a factor
	  ggplot(plot.data, aes(x=X1, y=prob, color=group:X2_level)) + 
	    geom_line(aes(linetype=X2_level), lwd=2) + # because linetype is instead aes(), it can vary according to the data (i.e. by X2_level)
	    labs(x="X1", y="P(outcome)", title="Probability of super important outcome") +
	    scale_color_manual(values=colors)
		
		
		
		
		
#####################################		
### reformatting data to wide

Here’s some thing we were working on in R Club today.

This example shows how to reformat data from (sort of) long to wide. We’ve got pre and post measurements for each subject, some subject-level variables (called dyad vars in the example), and two variables that vary by pre and post. These are the outcome of interest (DV) and a covariate (the length of the video). The data is “sort of” long in that pre and post are each on their own line, but the type of measure (DV or video length) is still each in its own column. To make it fully wide, where there’s only one line for each subject, first we need to make it fully long, and then spread it all out. I’m using dplyr and tidyr here since they’re such lovely tools, but of course there’s more than one way to go about this.

Enjoy!

Here’s the whole thing:

data <- data.frame(subj=sort(c(1:10, 1:10)), cond=rep(c("pre", "post"), 10), DV=rnorm(20), video=rnorm(20), dyadvar1=sort(c(1:10, 1:10)), dyadvar2=sort(c(1:10, 1:10)))

data

library(tidyr); library(dplyr)


wide.data <- data %>%
  gather(key="measure", value="value", DV:video) %>%
  unite(col=key, cond, measure)  %>%
  spread(key=key, value=value)
  
  
  library(knitr)
  data %>%
    gather(key="measure", value="value", DV:video)
	
	
	data %>%
	  gather(key="measure", value="value", DV:video) %>%
	  unite(col=key, cond, measure)
	  
	  
	  data %>%
	    gather(key="measure", value="value", DV:video) %>%
	    unite(col=key, cond, measure)  %>%
	    spread(key=key, value=value)
Returns a data.frame from RSiteSearch(string, "function") which can be sorted and subsetted by user specifications and viewed in an HTML table. The default sort puts first packages with the most matches (Count), with ties broken using the sum of the match scores for all the hits in that package (TotalScore), etc.

library("sos"); 

findFn("venn")
findFn("detail")

library(VennDiagram)

require(VennDiagram)
    venn.diagram(list(B = 1:1800, A = 1571:2020),fill = c("red", "green"),
  alpha = c(0.5, 0.5), cex = 2,cat.fontface = 4,lty =2, fontfamily =3, 
   filename = "trial2.emf");

library(venneuler)

v <- venneuler(c(A=450, B=1800, "A&B"=230))
plot(v)



library(venneuler)

## Modify the "factor" column, by renaming it and converting
## it to a character vector.
levels(data$factor) <- c("a", "b", "c")
data$factor <- as.character(data$factor)

## FUN is an anonymous function that determines which letters are present
## 2 or more times in the cluster and then pastes them together into 
## strings of a form that venneuler() expects.
##
inter <- aggregate(factor ~ cluster, data=data,
                   FUN = function(X) {
                       tab <- table(X)
                       names <- names(tab[tab>=2])
                       paste(sort(names), collapse="&")
                   })            
## Count how many clusters contain each combination of letters
counts <- table(inter$factor)
counts <- counts[names(counts)!=""]  # To remove groups with <2 of any letter
#  a   a&b a&b&c   a&c     b   b&c     c 
# 19    13    12    14    13     9    12 

## Convert to proportions for venneuler()
ps <- counts/sum(counts)

## Calculate the Venn diagram
vd <- venneuler(c(a=ps[["a"]], b = ps[["b"]], c = ps[["c"]],
                  "a&b" = ps[["a&b"]],
                  "a&c" = ps[["a&c"]],
                  "b&c" = ps[["b&c"]],
                  "a&b&c" = ps[["a&b&c"]]))
## Plot it!
plot(vd)

library(sem)

R.DHP <- readMoments(diag=FALSE, names=c('ROccAsp', 'REdAsp', 'FOccAsp', 
                'FEdAsp', 'RParAsp', 'RIQ', 'RSES', 'FSES', 'FIQ', 'FParAsp'))


model.dhp <- specifyModel()
    RParAsp  -> RGenAsp, gam11,  NA
    RIQ      -> RGenAsp, gam12,  NA
    RSES     -> RGenAsp, gam13,  NA
    FSES     -> RGenAsp, gam14,  NA
    RSES     -> FGenAsp, gam23,  NA
    FSES     -> FGenAsp, gam24,  NA
    FIQ      -> FGenAsp, gam25,  NA
    FParAsp  -> FGenAsp, gam26,  NA
    FGenAsp  -> RGenAsp, beta12, NA
    RGenAsp  -> FGenAsp, beta21, NA
    RGenAsp  -> ROccAsp,  NA,       1
    RGenAsp  -> REdAsp,  lam21,  NA
    FGenAsp  -> FOccAsp,  NA,       1
    FGenAsp  -> FEdAsp,  lam42,  NA
    RGenAsp <-> RGenAsp, ps11,   NA
    FGenAsp <-> FGenAsp, ps22,   NA
    RGenAsp <-> FGenAsp, ps12,   NA
    ROccAsp <-> ROccAsp, theta1, NA
    REdAsp  <-> REdAsp,  theta2, NA
    FOccAsp <-> FOccAsp, theta3, NA
    FEdAsp  <-> FEdAsp,  theta4, NA




R.DHP <- readMoments("sem.cov", diag=FALSE, 
                     names=c('ROccAsp', 'REdAsp', 'FOccAsp', 
                       'FEdAsp', 'RParAsp', 'RIQ', 'RSES',  
                       'FSES', 'FIQ', 'FParAsp'))
model.dhp <- specifyModel(file="sem.mod")
sem.dhp <- sem(model.dhp, R.DHP, 329,
               fixed.x=c('RParAsp', 'RIQ', 'RSES', 'FSES', 'FIQ', 'FParAsp'))            
capture.output(pathDiagram(sem.dhp, min.rank='RIQ, RSES, RParAsp, FParAsp, FSES, FIQ', 
            max.rank='ROccAsp, REdAsp, FEdAsp, FOccAsp'), file="sem.dot")



all.models <- as.data.frame(cbind(Sy.One, Sy.Two, Sy.Three, Sy.Four, Sy.Five, Sy.Six, Sy.Seven, Sy.Eight, Sy.Nine, Sy.Ten))

taylor.diagram(CSR, Sy.One, sd.arcs=T, ref.sd=T, pcex=1.5, main=NULL, pos.cor=F,
              xlab="Standard Deviation (cm)", ylab="Standard Deviation (cm)")

for (i in 1:dim(all.models)[2]) {
  model.wanted <- all.models[,i]
  taylor.diagram(CSR, model.wanted, sd.arcs=T, ref.sd=T, pcex=1.5, col=i, add=T, pos.cor=F)}

# Add legend
model.names <- c("Sy=1%","Sy=2%","Sy=3%","Sy=4%","Sy=5%","Sy=6%","Sy=7%","Sy=8%","Sy=9%","Sy=10%")
legend("top", model.names, pch=19, col=i, cex=1.0, bty="n", ncol=5)


obs = runif(100,1,100)
mod1 = runif(100,1,100)
mod2 = runif(100,1,100) 
mod3 = runif(100,1,100) 
taylor.diagram(obs,mod1)
taylor.diagram(obs,mod2,add=TRUE)
taylor.diagram(obs,mod3,add=TRUE)


taylor.bias <- function(ref, model, normalize = FALSE){
    R <- cor(model, ref, use = "pairwise")
    sd.f <- sd(model)
    sd.r <- sd(ref)
    m.f <- mean(model)
    m.r <- mean(ref)

    ## normalize if requested
    if (normalize) {
        m.f <- m.f/sd.r
        m.r <- m.r/sd.r
        sd.f <- sd.f/sd.r
        sd.r <- 1
        }

    ## calculate bias
    bias <- m.f - m.r

    ## coordinates for model and observations
    dd <- rbind(mp = c(sd.f * R, sd.f * sin(acos(R))), rp = c(sd.r, 0))

    ## find equation of line passing through pts
    v1 <- solve(cbind(1, dd[,1])) %*% dd[,2]    

    ## find perpendicular line
    v2 <- c(dd[1,2] + dd[1,1]/v1[2], -1/v1[2])

    ## find point defined by bias
    nm <- dd[1,] - c(0, v2[1])
    nm <- nm / sqrt(sum(nm^2))
    bp <- dd[1,] + bias*nm

    ## plot lines
    arrows(x0 = dd[1,1], x1 = bp[1], y0 = dd[1,2], y1 = bp[2], col = "red", length = 0.05, lwd = 1.5)
    lines(rbind(dd[2,], bp), col = "red", lty = 3)
    lines(dd, col = "red", lty = 3)
    }

library(plotrix)
obs = runif(100,1,100)
mod1 = runif(100,1,100)
taylor.diagram(obs,mod1)
taylor.bias(obs,mod1)




taylor.diagram.modified <- function (ref, model, add = FALSE, col = "red", 
                                    pch = 19, pos.cor = TRUE, xlab = "", ylab = "", 
                                    main = "Taylor Diagram", show.gamma = TRUE, 
                                    ngamma = 3, gamma.col = 8, sd.arcs = 0, ref.sd = FALSE, 
                                    grad.corr.lines = c(0.2, 0.4, 0.6, 0.8, 0.9), pcex = 1, 
                                    cex.axis = 1, normalize = FALSE, mar = c(5, 4, 6, 6),
                                    text, ...) #the added parameter
{
    grad.corr.full <- c(0, 0.2, 0.4, 0.6, 0.8, 0.9, 0.95, 0.99,1)
    R <- cor(ref, model, use = "pairwise")
    sd.r <- sd(ref)
    sd.f <- sd(model)
    if (normalize) {

    ... #I didn't copy here the full function because it's quite long: to obtain it
    ... #simply call `taylor.diagram` in the console or `edit(taylor.diagram)`.

            }
            S <- (2 * (1 + R))/(sd.f + (1/sd.f))^2
        }
    }
    points(sd.f * R, sd.f * sin(acos(R)), pch = pch, col = col, 
           cex = pcex)
    text(sd.f * R, sd.f * sin(acos(R)),  #the line to add
         labels=text, cex = pcex, pos=3) #You can change the pos argument to your liking
    invisible(oldpar)
}
